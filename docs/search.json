[
  {
    "objectID": "clean.html#tổng-quan-quá-trình-làm-sạch-dữ-liệu",
    "href": "clean.html#tổng-quan-quá-trình-làm-sạch-dữ-liệu",
    "title": "4  Làm sạch (p2)",
    "section": "4.1 Tổng quan quá trình làm sạch dữ liệu",
    "text": "4.1 Tổng quan quá trình làm sạch dữ liệu\nThường bao gồm các bước:\n\nLàm sạch tên cột (từ phần 1)\nKiểm tra datatype (từ phần 1)\nKiểm tra giá trị\nFormat bảng theo quy tắc dữ liệu gọn gàng\nNối bảng (nếu cần thiết)\nXử lý các dữ liệu lỗi"
  },
  {
    "objectID": "clean.html#làm-sạch-tên-cột-kiểm-tra-datatype",
    "href": "clean.html#làm-sạch-tên-cột-kiểm-tra-datatype",
    "title": "4  Làm sạch (p2)",
    "section": "4.2 Làm sạch tên cột & kiểm tra datatype",
    "text": "4.2 Làm sạch tên cột & kiểm tra datatype\nChúng ta sẽ dùng vaccine_data.xlsx từ phần trước\n\ndf <- read_excel(path = \"data/vaccine_data.xlsx\", sheet = 1)\n\n\n  \n    Làm sạch tên cột, thay đổi datatype\n  \n\ndf <- df %>% clean_names() %>%  \n  rename(\n    vgb_truoc_24 = vgb_24,\n    vgb_sau_24 = vgb_24_2\n  )\n\nCode tương ứng khi không dùng dấu %>%\n\n# ---Code không dùng %>%\ndf <- clean_names(df) \ndf <- rename(df, \n    vgb_truoc_24 = vgb_24,\n    vgb_sau_24 = vgb_24_2\n  )\n\n\n\n  \n    Kiểm tra và thay đổi datatype \n  \n\n# --- Điều chỉnh datatype\ndate_cols <- c(\"ngaysinh\", \"vgb_truoc_24\",\"vgb_sau_24\",\"vgb_1\",\"vgb_2\",\"vgb_3\",\"vgb_4\",\"hg_1\",\"hg_2\",\"hg_3\",\"hg_4\",\"uv_1\",\"uv_2\",\"uv_3\",\"uv_4\")\n\ndf <- mutate(df,\n    gioitinh = as.factor(gioitinh),\n    tinhtrang = ifelse(tinhtrang == \"theo dõi\", TRUE, FALSE)\n  ) %>% \n  mutate_at(date_cols, dmy) %>% \n  rename(theodoi = tinhtrang)\n\nCode tương ứng khi không dùng dấu %>%\n\ndf <- mutate(df,\n    gioitinh = as.factor(gioitinh),\n    tinhtrang = ifelse(tinhtrang == \"theo dõi\", TRUE, FALSE)\n  )\ndf <- mutate_at(df, date_cols, dmy) \ndf <- rename(df, theodoi = tinhtrang)"
  },
  {
    "objectID": "clean.html#kiểm-tra-giá-trị",
    "href": "clean.html#kiểm-tra-giá-trị",
    "title": "4  Làm sạch (p2)",
    "section": "4.3 Kiểm tra giá trị",
    "text": "4.3 Kiểm tra giá trị\nThường bao gồm các thao tác chính\n\nKiểm tra các giá trị NA\nKiểm tra các khoảng giá trị của từng cột/ kiểm tra các giá trị bất thường (outlier)\n\nTrong R có lệnh summary để người dùng có thể nhanh chóng kiểm tra các khoảng giá trị và số dữ liệu NA trong từng cột.\n\nsummary(df)\n\n       id         gioitinh     ngaysinh             huyen          \n Min.   :   1.0   nam:514   Min.   :2024-01-01   Length:1000       \n 1st Qu.: 250.8   nữ :486   1st Qu.:2024-01-25   Class :character  \n Median : 500.5             Median :2024-02-16   Mode  :character  \n Mean   : 500.5             Mean   :2024-02-16                     \n 3rd Qu.: 750.2             3rd Qu.:2024-03-10                     \n Max.   :1000.0             Max.   :2024-04-01                     \n                                                                   \n      xa                tinh            vgb_truoc_24       \n Length:1000        Length:1000        Min.   :0001-01-01  \n Class :character   Class :character   1st Qu.:2024-01-25  \n Mode  :character   Mode  :character   Median :2024-02-17  \n                                       Mean   :2005-10-03  \n                                       3rd Qu.:2024-03-11  \n                                       Max.   :2024-04-02  \n                                       NA's   :9           \n   vgb_sau_24             vgb_1                vgb_2           \n Min.   :0001-01-01   Min.   :0001-01-01   Min.   :0001-01-01  \n 1st Qu.:2024-01-26   1st Qu.:2024-02-05   1st Qu.:2024-02-16  \n Median :2024-02-17   Median :2024-02-27   Median :2024-03-09  \n Mean   :2003-10-11   Mean   :2014-01-01   Mean   :2009-11-18  \n 3rd Qu.:2024-03-11   3rd Qu.:2024-03-22   3rd Qu.:2024-03-31  \n Max.   :2024-04-03   Max.   :2024-04-18   Max.   :2024-05-03  \n NA's   :6            NA's   :4            NA's   :10          \n     vgb_3                vgb_4                 hg_1           \n Min.   :0001-01-01   Min.   :0001-01-01   Min.   :0001-01-01  \n 1st Qu.:2024-02-26   1st Qu.:2024-03-07   1st Qu.:2024-01-26  \n Median :2024-03-19   Median :2024-03-29   Median :2024-02-17  \n Mean   :2011-12-14   Mean   :2012-01-12   Mean   :2007-11-11  \n 3rd Qu.:2024-04-10   3rd Qu.:2024-04-21   3rd Qu.:2024-03-11  \n Max.   :2024-05-18   Max.   :2024-06-02   Max.   :2024-04-02  \n NA's   :10           NA's   :6            NA's   :5           \n      hg_2                 hg_3                 hg_4           \n Min.   :0001-01-01   Min.   :0001-01-01   Min.   :0001-01-01  \n 1st Qu.:2024-02-05   1st Qu.:2024-02-16   1st Qu.:2024-02-26  \n Median :2024-02-27   Median :2024-03-09   Median :2024-03-18  \n Mean   :1999-09-25   Mean   :2009-12-08   Mean   :2016-01-24  \n 3rd Qu.:2024-03-21   3rd Qu.:2024-03-31   3rd Qu.:2024-04-10  \n Max.   :2024-04-17   Max.   :2024-05-01   Max.   :2024-05-16  \n NA's   :6            NA's   :6            NA's   :7           \n      uv_1                 uv_2                 uv_3           \n Min.   :0001-01-01   Min.   :0001-01-01   Min.   :0001-01-01  \n 1st Qu.:2024-01-26   1st Qu.:2024-02-04   1st Qu.:2024-02-15  \n Median :2024-02-16   Median :2024-02-27   Median :2024-03-09  \n Mean   :2017-12-26   Mean   :2013-12-08   Mean   :2009-12-08  \n 3rd Qu.:2024-03-11   3rd Qu.:2024-03-21   3rd Qu.:2024-03-31  \n Max.   :2024-04-02   Max.   :2024-04-17   Max.   :2024-05-02  \n NA's   :12           NA's   :10           NA's   :6           \n      uv_4             theodoi       \n Min.   :0001-01-01   Mode :logical  \n 1st Qu.:2024-02-26   FALSE:504      \n Median :2024-03-19   TRUE :496      \n Mean   :2009-12-24                  \n 3rd Qu.:2024-04-10                  \n Max.   :2024-05-17                  \n NA's   :5                           \n\n\n\n4.3.1 Outlier\nĐể kiểm tra các giá trị outlier, ta có thể sử dụng boxplot để tìm các điểm giá trị cách xa các giá trị còn lại\n\nVí dụ: sử dụng boxplot để kiểm tra outlier của cột vgb_1\n\nboxplot(df$vgb_1)\n\n\n\n\n\n\n4.3.2 Kiểm tra giá trị giữa các cột\nNgoài ra, tuỳ vào bộ dữ liệu, có thể cần kiểm tra giá trị giữa các cột (VD: trong dữ liệu tiêm chủng có thể có mũi 2 trùng hoặc trước ngày tiêm mũi 1)\nVí dụ: lọc các hàng có ngày tiêm không đúng thứ tự\n\n# --- Kiểm tra các mũi vgb\ndf %>% \n  filter(\n  (vgb_truoc_24 > vgb_sau_24) | (vgb_sau_24 > vgb_1) | (vgb_1 > vgb_2) | (vgb_2 > vgb_3) | (vgb_3 > vgb_4) ) %>% \n  select(vgb_truoc_24, vgb_sau_24, vgb_1, vgb_2, vgb_3, vgb_4)\n\n# A tibble: 80 × 6\n   vgb_truoc_24 vgb_sau_24 vgb_1      vgb_2      vgb_3      vgb_4     \n   <date>       <date>     <date>     <date>     <date>     <date>    \n 1 2024-02-21   2024-02-20 2024-02-23 2024-03-09 2024-03-13 2024-03-23\n 2 2024-03-19   2024-03-20 2024-03-30 2024-04-14 2024-04-29 2024-04-27\n 3 2024-02-26   2024-02-27 2024-02-25 2024-03-11 2024-03-11 2024-03-26\n 4 2024-01-09   2024-01-10 2024-01-25 2024-02-09 2024-02-07 2024-02-22\n 5 2024-01-04   2024-01-05 2024-01-20 0001-01-01 2024-02-08 2024-02-18\n 6 2024-04-01   2024-04-02 2024-04-17 0001-01-01 2024-05-12 2024-05-27\n 7 2024-03-05   2024-03-06 2024-03-16 2024-03-15 2024-03-25 2024-04-09\n 8 2024-01-14   2024-01-15 2024-01-30 2024-01-29 2024-02-08 2024-02-18\n 9 2024-01-07   2024-01-08 2024-01-18 2024-01-28 2024-01-27 2024-02-11\n10 2024-01-06   2024-01-07 2024-01-22 2024-02-06 0001-01-01 0001-01-01\n# ℹ 70 more rows\n\n# --- Kiểm tra các mũi ho gà\ndf %>% \n  filter(\n  (hg_1 > hg_2) | (hg_2 > hg_3) | (hg_3 > hg_4)) %>% \n  select(hg_1, hg_2, hg_3, hg_4)\n\n# A tibble: 43 × 4\n   hg_1       hg_2       hg_3       hg_4      \n   <date>     <date>     <date>     <date>    \n 1 2024-01-04 0001-01-01 2024-01-22 2024-02-01\n 2 0001-01-01 2024-01-21 2024-02-05 0001-01-01\n 3 2024-03-14 2024-03-24 2024-04-08 2024-04-07\n 4 2024-01-16 2024-01-26 2024-02-10 2024-02-09\n 5 2024-02-10 0001-01-01 2024-03-11 2024-03-26\n 6 2024-02-17 2024-02-27 2024-03-13 2024-03-12\n 7 2024-03-16 2024-03-31 2024-03-29 2024-04-08\n 8 2024-03-16 2024-03-20 2024-04-04 2024-04-02\n 9 2024-01-15 2024-01-25 2024-02-04 2024-02-02\n10 2024-01-02 2024-01-12 0001-01-01 2024-01-20\n# ℹ 33 more rows\n\n# --- Kiểm tra các mũi uốn ván\ndf %>% \n  filter(\n  (uv_1 > uv_2) | (uv_2 > uv_3) | (uv_3 > uv_4) )%>% \n  select(uv_1, uv_2, uv_3, uv_4)\n\n# A tibble: 37 × 4\n   uv_1       uv_2       uv_3       uv_4      \n   <date>     <date>     <date>     <date>    \n 1 2024-04-01 0001-01-01 0001-01-01 2024-05-06\n 2 2024-01-03 2024-01-18 2024-01-19 0001-01-01\n 3 2024-02-03 2024-02-13 2024-02-28 2024-02-26\n 4 2024-02-17 2024-03-03 2024-03-01 2024-03-11\n 5 2024-02-16 0001-01-01 2024-03-12 2024-03-22\n 6 2024-02-25 2024-03-11 2024-03-26 2024-03-25\n 7 2024-03-30 2024-03-28 2024-04-07 2024-04-17\n 8 2024-04-01 2024-03-31 2024-04-10 2024-04-25\n 9 2024-02-10 2024-02-20 0001-01-01 2024-03-02\n10 2024-03-08 2024-03-23 2024-04-02 2024-04-01\n# ℹ 27 more rows"
  },
  {
    "objectID": "clean.html#data-gọn-gàng-tidy-data",
    "href": "clean.html#data-gọn-gàng-tidy-data",
    "title": "4  Làm sạch (p2)",
    "section": "4.4 Data gọn gàng (tidy data)",
    "text": "4.4 Data gọn gàng (tidy data)\nDữ liệu gọn gàng có các đặc điểm sau:1\n\nMỗi biến là một cột; mỗi cột là một biến\nMỗi quan sát là một hàng; mỗi hàng là một quan sát\nMỗi giá trị nằm trong một ô; mỗi ô chứa một giá trị duy nhất\n\n\n4.4.1 Format bảng\nBảng dữ liệu hiện tại chưa tuân theo quy tắc tidy data vì các cột kháng nguyên (vgb_1, vgb_2, …) không phải là biến và mỗi hàng đang chứa nhiều quan sát (ngày tiêm cho các mũi tiêm khác nhau).\nHiện tại bảng dữ liệu đang ở định dạng ngang (wide), khi nhiều quan sát của cùng chủ thể (trong VD này là trẻ được tiêm) được lưu trữ trong một hàng duy nhất. Điều này có thể hữu ích cho việc hiển thị, tuy nhiên không lý tưởng cho việc phân tích.\nĐể tuân theo quy tắc tidy data, ta cần format bảng dữ liệu sang định dạng dọc (long)\nĐể format bảng dữ liệu trong R, ta có thể sử dụng các lệnh sau.\n\npivot_longer() - chuyển dữ liệu từ dạng ngang sang dọc.\npivot_wider() - chuyển dữ liệu từ dạng dọc sang ngang.\n\n\n\ncols <- which(str_ends(colnames(df), \"[:digit:]\"))\ndf <- pivot_longer(df,\n      cols = any_of(cols),\n      # đặt tên mới cho biến\n      names_to = \"khangnguyen\",\n      # đặt tên mới cho cột giá trị tương ứng\n      values_to = \"ngaytiem\") \n\nhead(df)\n\n# A tibble: 6 × 9\n     id gioitinh ngaysinh   huyen     xa    tinh  theodoi khangnguyen ngaytiem  \n  <dbl> <fct>    <date>     <chr>     <chr> <chr> <lgl>   <chr>       <date>    \n1     1 nam      2024-02-27 Bình Chá… Phườ… Thàn… TRUE    vgb_truoc_… 2024-02-28\n2     1 nam      2024-02-27 Bình Chá… Phườ… Thàn… TRUE    vgb_sau_24  2024-02-29\n3     1 nam      2024-02-27 Bình Chá… Phườ… Thàn… TRUE    vgb_1       2024-03-10\n4     1 nam      2024-02-27 Bình Chá… Phườ… Thàn… TRUE    vgb_2       2024-03-20\n5     1 nam      2024-02-27 Bình Chá… Phườ… Thàn… TRUE    vgb_3       2024-03-20\n6     1 nam      2024-02-27 Bình Chá… Phườ… Thàn… TRUE    vgb_4       2024-04-04"
  },
  {
    "objectID": "clean.html#kết-hợp-dữ-liệu",
    "href": "clean.html#kết-hợp-dữ-liệu",
    "title": "4  Làm sạch (p2)",
    "section": "4.5 Kết hợp dữ liệu",
    "text": "4.5 Kết hợp dữ liệu\nTrong nhiều trường hợp, dữ liệu bị chia thành nhiều bảng khác nhau và để phân tích thì chúng ta phải kết hợp các bảng lại.\nĐể nối 2 bảng với nhau trong R, ta sử dụng 1 trong các lệnh join của package dplyr sau đây\n\n\n\n\n\n\n\n\nFunction\nCông dụng\nGIF minh hoạ\n\n\n\n\nleft_join()\nNối ngoài bên trái\n\n\n\nright_join()\nNối ngoài bên phải\n\n\n\ninner_join()\nNối trong\n\n\n\nfull_join()\nNối ngoài\n\n\n\n\nĐể sử dụng lệnh join, ta cần cung cấp cho R các thông tin sau:\n\n2 bảng cần nối\ncác cột chung để nối bằng lệnh join_by (R mặc định nối 2 bảng bằng cột có tên giống nhau)\n\nTổng hợp các lệnh join cùng GIF minh hoạ\nVí dụ:\nNối cột để kiểm tra các quận huyện trong bộ dữ liệu và xoá các dữ liệu có Quận/Huyện không hợp lý\n\n  \n    Thông tin về bảng dữ liệu qhpx_hcm.rds\n  \nDùng để đối chiếu và kiểm tra xem các quận huyện trong bộ dữ liệu vaccine có hợp lệ hay không (quận + huyện có tồn tại hay không). Ví dụ một số dữ liệu không hợp lệ [ (Quận 6, Xã Bình Trung), (Quận 6, Xã Xuân Bắc), …]\nĐồng thời cung cấp tên quận và xã được đồng nhất\nTừ điển biến số\n\n\n\n\n\n\n\nTên biến\nÝ nghĩa\n\n\n\n\nqh\ntên quận/huyện xuất hiện trong bộ dữ liệu vaccine\n\n\npx\ntên phường/xã xuất hiện trong bộ dữ liệu vaccine\n\n\nqh_update\ntên quận/huyện được đồng bộ hoá theo format “Quận số” đối với các quận có tên số hoặc “Tên quận” đối với quận chữ\nVD: “Quận Thủ Đức”/ “Thành phố Thủ đức” được đồng bộ hoá thành “Thủ Đức”\n\n\npx_update\ntên phường/xã được đồng bộ hoá theo format “Phường số” đối với các phường có tên số hoặc “Tên phường” đối với phường chữ\n\n\nma_px\nmã cho phường/xã\n\n\n\n\n\n# --- Đọc bảng quận huyện phường xã \nqhpx <- readRDS(\"data/qhpx_hcm.rds\")\n\n# --- Nối 2 bảng bằng lệnh left_join\njoined_df <- left_join(df, qhpx, by = join_by(huyen == qh, xa == px)) \n\nSau khi nối bằng left_join, các hàng của bảng trái (df) không nối được với bảng phải (qhpx) sẽ được chèn giá trị NA\nVì vậy, các hàng có qh_update hoặc px_update là NA sẽ là các hàng có quận/huyện và phường/xã không khợp lệ\nTa có thể xem các hàng có lỗi như sau\n\njoined_df %>% filter(is.na(qh_update))"
  },
  {
    "objectID": "clean.html#xử-lý-dữ-liệu",
    "href": "clean.html#xử-lý-dữ-liệu",
    "title": "4  Làm sạch (p2)",
    "section": "4.6 Xử lý dữ liệu",
    "text": "4.6 Xử lý dữ liệu\nThường bao gồm\n\nChỉnh sửa giá trị dữ liệu\nLọc trùng\nLọc hàng\n\n\n4.6.0.1 Chỉnh sửa giá trị dữ liệu\nCác trường hợp có thể cần chỉnh sửa lại dữ liệu:\n\nDữ liệu NA (trống)\nCác dữ liệu dạng TRUE/FALSE được hiển thị bằng cách khác trong dữ liệu gốc (VD: Đánh dấu X hoặc bỏ trống trong file excel)\nĐồng nhất dữ liệu\n\nMột số lệnh liên quan:\n\nreplace_na thay thế giá trị NA bằng giá trị được cung cấp\nis.na chuyển thành định dạng logical, các dữ liệu trống (NA) có giá trị TRUE và ngược lại\nifelse mã hoá theo điều kiện đơn giản, chỉ có 2 trường hợp khi đáp ứng điều kiện hoặc không.\ncase_when mã hóa giá trị cho nhiều trường hợp nhất định\n\nCode mô phỏng sử dụng các lệnh trên\n\n# --- Thay thế các giá trị NA trong cột col1 thành \"default\"\ndf %>% \n  mutate(col1 = replace_na(col1, \"default\"))\n\n# --- Thay thế các giá trị được đánh dấu trong col2 thành TRUE và ngược lại\ndf %>% \n  mutate(col2 = !is.na(col2))\n# Cách làm khác bằng ifelse\ndf %>% \n  mutate(col2 = ifelse(is.na(col2), FALSE, TRUE))\n\n# --- Mã hoá giá trị cho nhiều trường hợp\ndf %>% \n  mutate(col2 = case_when(\n    condition_1 ~ val_1, # nếu col2 thoả điều kiện condition_1 -> gán giá trị val_1\n    condition_2 ~ val_2, # nếu col2 thoả điều kiện condition_2 -> gán giá trị val_2\n    condition_3 ~ val_3, # nếu col2 thoả điều kiện condition_3 -> gán giá trị val_3\n    .default = default_val # trong các trường hợp khác -> gán giá trị default_val\n  ))\n\nThực hiện các bước chỉnh sửa giá trị dữ liệu trên bộ dữ liệu vaccine\nĐồng nhất tên quận, phường theo cột qh_update, px_update\n\njoined_df <- joined_df %>% mutate(qh = qh_update, px = px_update)\n\nĐối với trường hợp này, các giá trị NA sẽ được loại bỏ ở bước tiếp theo thay vì được thay thế bằng các giá trị khác\n\n\n4.6.0.2 Lọc hàng\nBước làm sạch điển hình sau khi đã làm sạch các cột và các giá trị được mã hóa lại đó là lọc bộ dữ liệu cho các hàng cụ thể\nĐể lọc hàng, ta dùng lệnh filter kết hợp với điều kiện lọc như đã học ở phần ?sec-filter-condition\nMột số điều kiện lọc:\n\nLoại bỏ NA: !is.na()\nLọc bằng số thứ tự hàng\nLọc theo giá trị\n\n\n\n\n\n\n\nLệnh drop_NA\n\n\n\ndrop_NA là lệnh để nhanh chóng drop các hàng có chứa giá trị NA (ở bất kỳ cột nào)\nNếu tên cột được cung cấp, drop_NA chỉ drop các hàng có giá trị NA ở các cột được quy định\n\n# --- drop tất cả các hàng có giá trị NA\ndf %>% drop_na()\n\n# --- chỉ drop các hàng có giá trị NA tại cột ngaytiem\ndf %>% drop_na(ngaytiem)\n\n\n\n\n\n\n\n\n\nLọc hàng khi còn giá trị NA\n\n\n\nViệc lọc với điều kiện lớn hơn (>) hoặc nhỏ hơn (<) một ngày hoặc số có thể loại bỏ bất kỳ hàng nào có giá trị NA. Điều này là do NA được coi là giá trị lớn hoặc nhỏ vô hạn.\n\n\nThực hiện lọc giá trị trên dữ liệu vaccine\nLoại bỏ các dữ liệu có qh px không hợp lý\n\njoined_df <- joined_df %>% filter(!is.na(qh_update)) \n\nLoại bỏ các dữ liệu có ngày tiêm NA\n\njoined_df <- joined_df %>% drop_na(ngaytiem)\n\nLoại bỏ các ngày tiêm trước ngày sinh\n\njoined_df <- joined_df %>% filter(ngaytiem >= ngaysinh)\n\n\n\n4.6.0.3 Lọc trùng\nLệnh distinct của gói dplyr sẽ dữ lại 1 hàng duy nhất trong các hàng có giá trị bị trùng.\nLệnh distinct mặc định sẽ kiểm tra giá trị của tất cả các cột (2 hàng được đánh giá là trùng khi tất cả các trị của chúng giống nhau).\n\ndf <- df %>% distinct()"
  },
  {
    "objectID": "clean.html#biến-đổi-cột",
    "href": "clean.html#biến-đổi-cột",
    "title": "4  Làm sạch (p2)",
    "section": "4.7 Biến đổi cột",
    "text": "4.7 Biến đổi cột\n\n4.7.1 Chọn cột\nLệnh select của dplyr thường được sử dụng để chọn lọc cột một cách nhanh chóng\n\nĐể chọn cột, chỉ cần gõ tên các cột được chọn, phân cách bởi dấu ,\nĐể xoá cột, thêm dấu - trước tên cột\n\nVí dụ: xoá các cột qh_update, px_update sau khi đã chỉnh sửa tên quận, xã\n\n# --- Xóa cột \njoined_df <- joined_df %>% select(-qh_update, -px_update)\n\n\n\n4.7.2 Tạo cột mới\nNhư đã được nhắc đến trong các phần trước, lệnh mutate được sử dụng để tạo cột mới hoặc chỉnh sửa giá trị của cột.\nMột số argument (tham số) thông dụng của lệnh mutate\n\n.before / .after quy định vị trí của cột mới trước hoặc sau cột được chỉ định\n.keep quy định các cột được giữ lại sau lệnh mutate\n\n\"all\" giữ lại tất cả các cột gốc (default)\n\"none\" không giữ lại các cột gốc\n\"used\" giữ lại các cột được sử dụng trong mutate\n\"unused\" giữ lại các cột không được sử dụng\n\n\nVD: tạo cột mới tên qhpx kết hợp cột huyen, xa\n\ndf %>% \n  mutate(\n    # tạo cột mới kết hợp quận và phường\n    qhpx = str_glue(\"{huyen}_{xa}\"),\n    .keep = \"used\", # giữ các cột được sử dụng\n    .after = xa # cột được tạo sau cột xa\n  )\n\n# A tibble: 14,000 × 3\n   huyen      xa                   qhpx                           \n   <chr>      <chr>                <glue>                         \n 1 Bình Chánh Phường Bình Hưng Hòa Bình Chánh_Phường Bình Hưng Hòa\n 2 Bình Chánh Phường Bình Hưng Hòa Bình Chánh_Phường Bình Hưng Hòa\n 3 Bình Chánh Phường Bình Hưng Hòa Bình Chánh_Phường Bình Hưng Hòa\n 4 Bình Chánh Phường Bình Hưng Hòa Bình Chánh_Phường Bình Hưng Hòa\n 5 Bình Chánh Phường Bình Hưng Hòa Bình Chánh_Phường Bình Hưng Hòa\n 6 Bình Chánh Phường Bình Hưng Hòa Bình Chánh_Phường Bình Hưng Hòa\n 7 Bình Chánh Phường Bình Hưng Hòa Bình Chánh_Phường Bình Hưng Hòa\n 8 Bình Chánh Phường Bình Hưng Hòa Bình Chánh_Phường Bình Hưng Hòa\n 9 Bình Chánh Phường Bình Hưng Hòa Bình Chánh_Phường Bình Hưng Hòa\n10 Bình Chánh Phường Bình Hưng Hòa Bình Chánh_Phường Bình Hưng Hòa\n# ℹ 13,990 more rows"
  },
  {
    "objectID": "clean.html#bài-tập",
    "href": "clean.html#bài-tập",
    "title": "4  Làm sạch (p2)",
    "section": "4.8 Bài tập",
    "text": "4.8 Bài tập\n\n  \n    Load file  gdp-capita.xlsx \n  \n\nlibrary(readxl)\nlibrary(janitor)\nlibrary(tidyverse)\n\ngdp <- read_excel(path = \"data/gdp-capita.xlsx\", sheet = 1) %>% clean_names()\n\n\n\n  \n    Xoay trục dữ liệu\n  \nBảng dữ liệu hiện tại chưa tuân theo quy tắc tidy data vì các cột 2015 - 2022 không phải là biến và mỗi hàng đang chứa nhiều quan sát (quan sát cho các năm từ 2015 - 2022).\nHiện tại bảng dữ liệu đang ở định dạng ngang (wide), khi nhiều quan sát của cùng chủ thể (trong VD này là các quốc gia) được lưu trữ trong một hàng duy nhất.\n\ngdp <- gdp %>% \n  pivot_longer(\n    cols = starts_with(\"x\"),\n    # đặt tên mới cho biến\n    names_to = \"year\",\n    # đặt tên mới cho cột giá trị tương ứng\n    values_to = \"gdp\")\nhead(gdp)\n\n# A tibble: 6 × 4\n  country_name country_code year     gdp\n  <chr>        <chr>        <chr>  <dbl>\n1 Aruba        ABW          x2015 28419.\n2 Aruba        ABW          x2016 28450.\n3 Aruba        ABW          x2017 29329.\n4 Aruba        ABW          x2018 30918.\n5 Aruba        ABW          x2019 31903.\n6 Aruba        ABW          x2020 24008.\n\n\n\n\n  \n    Đọc sheet thứ 2 của file gdp-capita.xlsx và nối với gdp\n  \n\nmt <- read_excel(path = \"data/gdp-capita.xlsx\", sheet = 2) %>% \n  clean_names()\n\n# --- Nối 2 bảng bằng lệnh left_join\n# Trong trường hợp này, tuy lệnh join_by không cần thiết nhưng có thể giúp cho code rõ ràng hơn \njoined_gdp <- left_join(gdp, mt, by = join_by(country_code == country_code))\nhead(joined_gdp)\n\n# A tibble: 6 × 8\n  country_name country_code year     gdp region       income_group special_notes\n  <chr>        <chr>        <chr>  <dbl> <chr>        <chr>        <chr>        \n1 Aruba        ABW          x2015 28419. Latin Ameri… High income  <NA>         \n2 Aruba        ABW          x2016 28450. Latin Ameri… High income  <NA>         \n3 Aruba        ABW          x2017 29329. Latin Ameri… High income  <NA>         \n4 Aruba        ABW          x2018 30918. Latin Ameri… High income  <NA>         \n5 Aruba        ABW          x2019 31903. Latin Ameri… High income  <NA>         \n6 Aruba        ABW          x2020 24008. Latin Ameri… High income  <NA>         \n# ℹ 1 more variable: table_name <chr>\n\n\n\n\n  \n    Tạo cột mới tên country_details nối cột country_name và country_code theo format \"Name: [country_name] Code: [country_code]\" \n  \n\njoined_gdp %>% \n  mutate(\n    # tạo cột mới kết hợp 3 cột country_name, country_code, region\n    country_details = str_glue(\"Name: {country_name} Code:{country_code} Region: {region}\"),\n    .keep = \"used\", # giữ các cột được sử dụng\n    .before = country_name # đặt cột country_details trước cột country_name\n  )\n\n# A tibble: 2,128 × 4\n   country_details                              country_name country_code region\n   <glue>                                       <chr>        <chr>        <chr> \n 1 Name: Aruba Code:ABW Region: Latin America … Aruba        ABW          Latin…\n 2 Name: Aruba Code:ABW Region: Latin America … Aruba        ABW          Latin…\n 3 Name: Aruba Code:ABW Region: Latin America … Aruba        ABW          Latin…\n 4 Name: Aruba Code:ABW Region: Latin America … Aruba        ABW          Latin…\n 5 Name: Aruba Code:ABW Region: Latin America … Aruba        ABW          Latin…\n 6 Name: Aruba Code:ABW Region: Latin America … Aruba        ABW          Latin…\n 7 Name: Aruba Code:ABW Region: Latin America … Aruba        ABW          Latin…\n 8 Name: Aruba Code:ABW Region: Latin America … Aruba        ABW          Latin…\n 9 Name: Africa Eastern and Southern Code:AFE … Africa East… AFE          <NA>  \n10 Name: Africa Eastern and Southern Code:AFE … Africa East… AFE          <NA>  \n# ℹ 2,118 more rows\n\n\n\n\n\n\n\n1. Wickham, H. Tidy Data. Journal of Statistical Software 59, (2014)."
  },
  {
    "objectID": "analysis.html#summarize",
    "href": "analysis.html#summarize",
    "title": "5  Phân tích",
    "section": "5.1 summarize",
    "text": "5.1 summarize\nHàm summarize của package dplyr được sử dụng chung với các hàm thống kê (aggregation function) để tạo bảng mô tả thống kê cho dữ liệu.\n\nMột số hàm thống kê thông dụng.\n\n\n\nHàm\nCông dụng\n\n\n\n\nmean()\ntính trung bình\n\n\nmin()\ngiá trị nhỏ nhất\n\n\nmax()\ngiá trị lớn nhất\n\n\nmedian()\nsố trung vị\n\n\nquantile()\nđiểm phân vị\n\n\nsd()\nđộ lệch chuẩn\n\n\n\nHàm group_by được sử dụng khi cần chia dữ liệu theo nhóm trước khi tính toán thống kê cho từng nhóm."
  },
  {
    "objectID": "analysis.html#gtsummary",
    "href": "analysis.html#gtsummary",
    "title": "5  Phân tích",
    "section": "5.2 gtsummary",
    "text": "5.2 gtsummary\nPackage gtsummary có thể hỗ trợ người dùng vẽ các bảng thống kê một cách nhanh chóng\n\ndf %>% tbl_summary()"
  },
  {
    "objectID": "analysis.html#các-phép-kiểm-thường-dùng",
    "href": "analysis.html#các-phép-kiểm-thường-dùng",
    "title": "5  Phân tích",
    "section": "5.3 Các phép kiểm thường dùng",
    "text": "5.3 Các phép kiểm thường dùng"
  },
  {
    "objectID": "analysis.html#so-sánh",
    "href": "analysis.html#so-sánh",
    "title": "5  Phân tích",
    "section": "5.4 So sánh",
    "text": "5.4 So sánh"
  },
  {
    "objectID": "viz.html#ggplot",
    "href": "viz.html#ggplot",
    "title": "6  Trực quan hóa",
    "section": "6.1 ggplot",
    "text": "6.1 ggplot\n\n6.1.1 Giới thiệu ggplot\nVẽ đồ thị với ggplot2 dựa trên việc “thêm” các lớp đồ thị và các phần tử thiết kế chồng lên nhau, với mỗi lệnh được thêm vào các lệnh trước bằng một dấu cộng +\nThứ tự cơ bản để vẽ 1 đồ thị ggplot như sau:\n\nBắt đầu với lớp nền bằng lệnh ggplot() - lệnh này “mở” ggplot và cho phép các hàm tiếp theo được thêm vào với dấu +. Thông thường, đối tượng cần vẽ được chỉ định trong lệnh này\nThêm các lớp geom - mỗi lớp geom sẽ thêm 1 loại biểu đồ (VD: biểu đồ cột, biểu đồ đường, biểu đồ phân tán, histogram). Các hàm này đều bắt đầu bằng geom_\nThêm các yếu tố thiết kế vào đồ thị, chẳng hạn như nhãn trục, tiêu đề, phông chữ, kích thước, phối màu, chú giải hoặc xoay trục\n\n\n# vẽ đồ thị từ bảng dữ liệu my_data\nggplot(data = my_data)+                   \n  geom_point(                             # vẽ đồ thị phân tán\n    mapping = aes(x = col1, y = col2),    # dùng giá trị cột col1 làm trục x và col2 làm trục y\n    color = \"red\")+                       # tuỳ chọn khác\n  labs()+                                 # thêm tên bảng và tên các trục\n  theme()                                 # chỉnh thêm màu sắc, font, size\n\n\n\n\n\n\n\nChọn màu cho ggplot\n\n\n\nNgoài các màu cơ bản, ta có thể quy định màu trong R dưới dạng hex color\nVD\n\nggplot(data = my_data)+                   \n  geom_point(                             \n    mapping = aes(x = col1, y = col2),    \n    color = \"#03d3fc\")\n\nĐể có được hex color, ta có thể google “hex color”, chọn màu phù hợp và copy HEX\n\n\n\n\n\n6.1.2 Một số geom_ thông dụng\n\nHistograms - geom_histogram()\nBiểu đồ cột - geom_bar() hoặc geom_col()\nBox plots - geom_boxplot()\nĐiểm (vd: biểu đồ phân tán) - geom_point()\nBiểu đồ đường - geom_line() hoặc geom_path()\nĐường xu hướng - geom_smooth()\n\n\n\n\n\n\n\nArgument stat của hàm geom\n\n\n\n\n\"identity\" lấy dữ liệu thô\n\"count\" đếm số quan sát (số hàng) trong từng phân nhóm\n\"sum\" tính tổng của các hàng trong từng phân nhóm\n\n\n\n\n\n6.1.3 Facet\nFacets, hay “chia nhỏ biểu đồ”, được sử dụng để chia một biểu đồ thành nhiều phần nhỏ, với mỗi phần (“facet”) đại diện cho một nhóm của dữ liệu.\nTrong ggplot, có 2 loại facet chính\n\nfacet_wrap() hiện thị các biểu đồ khác nhau cho từng nhóm của một biến số. (VD: thể hiện các đường cong dịch bệnh khác nhau cho từng khu vực).\nfacet_grid() áp dụng khi muốn đưa một biến thứ hai vào sắp xếp các biểu đồ con. Ở đây mỗi ô thể hiện sự giao nhau của các giá trị giữa hai cột.\n\nVD:\n\n\n\n\n\n\n\nfacet_wrap\nfacet_grid\n\n\n\n\nbiểu đồ số ca bệnh sốt rét chia theo tỉnh (tên tỉnh ở phía trên mỗi biểu đồ)\nbiểu đồ số ca bệnh sốt rét chia theo tỉnh và nhóm tuổi"
  },
  {
    "objectID": "viz.html#plotly",
    "href": "viz.html#plotly",
    "title": "6  Trực quan hóa",
    "section": "6.2 Plotly",
    "text": "6.2 Plotly\nPackage plotly cung cấp lệnh ggplotly giúp người dùng nhanh chóng biến biểu đồ của ggplot thành biểu đồ tương tác (interactive plot).\nVD\n\n# Vẽ biểu đồ bằng ggplot \nplot <- ggplot(data = my_data)+                   \n  geom_point(                             \n    mapping = aes(x = col1, y = col2),    \n    color = \"#03d3fc\")\n\n# Dùng lệnh ggplotly để biến thành biểu đồ tương tác\nggplotly(plot)\n\n\n\n\n\n\n\nLưu ý\n\n\n\nKhi knit file .Rmd sang các định dạng file khác, tính tương tác của đồ thị chỉ còn khi người dùng knit thành file .html"
  },
  {
    "objectID": "viz.html#vẽ-bản-đồ",
    "href": "viz.html#vẽ-bản-đồ",
    "title": "6  Trực quan hóa",
    "section": "6.3 Vẽ bản đồ",
    "text": "6.3 Vẽ bản đồ\n\n6.3.0.1 Dữ liệu bản đồ\nTrước tiên, ta cần dữ liệu để vẽ biểu đồ trong R. Trong khoá học này ta sẽ sử dụng dữ liệu được cấp bởi GADM.\n\nĐể download dữ liệu biểu đồ Việt Nam, thực hiện các bước sau:\n\nVào trang https://gadm.org/download_country.html\nChọn Vietnam trong danh sách Country\nBấm Geopackage\nFile được tải về có tên là gadm41_VNM.gpkg\n\n\n\n\n\n\n\nLưu ý\n\n\n\n\nCác nguồn bản đồ mở thường sẽ không có các phần lãnh thổ tranh chấp (VD: Hoàng Sa, Trường Sa)\nCác thay đổi về bản đồ hành chính có thể không được cập nhật kịp thời (VD: các quận được sáp nhập thành TP. Thủ Đức)\n\n\n\nDữ liệu bản đồ tải về sẽ có 3 cấp bậc\n\nCấp tỉnh/ thành phố\nCấp quận/ huyện\nCấp phường/ xã\n\nĐể đọc dữ liệu bản đồ, dùng lệnh st_read của package sf\nĐể vẽ dữ liệu đọc được, dùng lệnh geom_sf của ggplot\n\n# Đọc dữ liệu bản đồ\nmap_path <- \"data\"\nvn_tinh <- st_read(dsn = file.path(map_path, \"gadm41_VNM.gpkg\"), layer = \"ADM_ADM_1\")\nvn_qh <- st_read(dsn = file.path(map_path, \"gadm41_VNM.gpkg\"), layer = \"ADM_ADM_2\")\nvn_px <- st_read(dsn = file.path(map_path, \"gadm41_VNM.gpkg\"), layer = \"ADM_ADM_3\")\n\n\n# Vẽ dữ liệu đọc được\nvn_tinh %>% \n  ggplot() +\n  ggplot2::geom_sf()\n\n\n\nvn_qh %>% \n  ggplot() +\n  ggplot2::geom_sf()\n\n\n\nvn_px %>% \n  ggplot() +\n  ggplot2::geom_sf()\n\n\n\n\n\n\n\n\n\n\nDebug package sf\n\n\n\nNếu gặp lỗi như sau khi chạy geom_sf()\nIn CPL_crs_from_input(x) :\n  GDAL Error 1: PROJ: proj_create_from_database: Cannot find proj.db\nChạy dòng code sau để giải quyết lỗi (@edzer)\n\nremove.packages(\"sf\")\ninstall.packages('sf', repos = c('https://r-spatial.r-universe.dev'))\nlibrary(sf)\n\n\n\n\n\n6.3.1 Leaflet\nGói leaflet được dùng để vẽ bản đồ tương tác.\nChúng ta sử dụng leaflet thay vì ggplot + plotly vì bản đồ vẽ bởi leaflet thường đẹp hơn\n\n\nlabels <- sprintf(\"<strong> %s </strong> \", vn_tinh$NAME_1) %>%\n  lapply(htmltools::HTML)\nleaflet(vn_tinh) %>%\n  #addTiles() %>%\n  addPolygons(color = \"grey\", weight = 1,label = labels)"
  },
  {
    "objectID": "viz-practice.html#biểu-đồ-mẫu",
    "href": "viz-practice.html#biểu-đồ-mẫu",
    "title": "7  Thực hành trực quan hóa",
    "section": "7.1 Biểu đồ mẫu",
    "text": "7.1 Biểu đồ mẫu\nBiểu đồ dưới đây nằm trong bài báo “Mapping routine measles vaccination in low- and middle-income countries”1 được đăng trên tạp chí Nature (IF 2022 = 64.8). Biểu đồ thể hiện tương quan giữa sự thay đổi bất bình đẳng địa lý và sự thay đổi độ phủ vaccine MCV1 của các quốc gia thu nhập thấp và trung bình từ năm 2000 đến năm 2019.\n\nChúng ta sẽ vẽ lại biểu đồ này bằng ggplot. Để đơn giản, chúng ta bỏ bớt một số chi tiết và sẽ vẽ biểu đồ sau:\n\n\n7.1.1 Các bước thực hành\nĐầu tiên cần gọi library ggplot để vẽ biểu đồ và ggsci cho bảng màu.\n\nlibrary(ggplot2)\nlibrary(ggsci)\n\nNhìn vào biểu đồ, chúng ta thấy trục x (nằm ngang) là sự thay đổi độ phủ vaccine, trục y (nằm dọc) là sự thay đổi bất bình đẳng địa lý. Có 10 quốc gia được hiển thị tên là Angola, Papua New Guinea, Pakistan, Chad, Ethiopia, Kenya, Nigeria, Liberia, Burkina Faso, India.\nVậy chúng ta cần một data frame có ít nhất 3 cột: (1) tên quốc gia, (2) sự thay đổi độ phủ vaccine, (3) sự thay đổi bất bình đẳng địa lý.\n\ncountry <- c(\"Angola\", \"Papua New Guinea\", \"Pakistan\", \"Chad\", \"Ethiopia\", \"Kenya\", \"Nigeria\", \"Liberia\", \"Burkina Faso\", \"India\")\ncoverage <- c(-0.11, -0.35, 0.12, 0.14, 0.32, 0.07, 0.2, 0.18, 0.3, 0.35)\ninequality <- c(0.1, 0.08, 0.05, 0.01, 0.005, -0.06, -0.07, -0.11, -0.13, -0.16)\ndf_plot <- data.frame(country, coverage, inequality)\ndf_plot\n\n            country coverage inequality\n1            Angola    -0.11      0.100\n2  Papua New Guinea    -0.35      0.080\n3          Pakistan     0.12      0.050\n4              Chad     0.14      0.010\n5          Ethiopia     0.32      0.005\n6             Kenya     0.07     -0.060\n7           Nigeria     0.20     -0.070\n8           Liberia     0.18     -0.110\n9      Burkina Faso     0.30     -0.130\n10            India     0.35     -0.160\n\n\nChúng ta sẽ vẽ biểu đồ cho 10 quốc gia này trước. Dạng biểu đồ scatterplot trong ggplot tương ứng với geom_point().\n\nggplot(df_plot, aes(x = coverage, y = inequality)) +\n  geom_point()\n\n\n\n\nĐể hiển thị tên quốc gia, chúng ta thêm geom_text() với label là tên nước (country).\n\nggplot(df_plot, aes(x = coverage, y = inequality)) +\n  geom_point() +\n  geom_text(aes(label = country))\n\n\n\n\nHiện giờ chữ đang đè lên các điểm, chúng ta điều chỉnh vị trí của chữ bằng arguments hjust và vjust của geom_text(). Một số tên nước bị cắt mất như Papua New Guinea, chúng ta điều chỉnh lại giới hạn hiển thị của các trục tọa độ bằng xlim(), ylim() để hiển thị lại đầy đủ.\n\nggplot(df_plot, aes(x = coverage, y = inequality)) +\n  geom_point() +\n  geom_text(aes(label = country), hjust = -0.2, vjust = 0.2) +\n  xlim(c(-0.35, 0.55)) +\n  ylim(c(-0.17, 0.1))\n\n\n\n\nCác điểm trong biểu đồ gốc có màu sắc và kích thước to nhỏ khác nhau, vậy trong data frame cần có thêm 1 cột màu sắc và 1 cột kích thước.\n\ndf_plot$size <- c(1.1, 0.6, 3, 1, 2, 1.1, 3, 0.7, 1.1, 8)\ndf_plot$color <- c(1, 2, 3, 1, 1, 1, 1, 1, 1, 3)\ndf_plot\n\n            country coverage inequality size color\n1            Angola    -0.11      0.100  1.1     1\n2  Papua New Guinea    -0.35      0.080  0.6     2\n3          Pakistan     0.12      0.050  3.0     3\n4              Chad     0.14      0.010  1.0     1\n5          Ethiopia     0.32      0.005  2.0     1\n6             Kenya     0.07     -0.060  1.1     1\n7           Nigeria     0.20     -0.070  3.0     1\n8           Liberia     0.18     -0.110  0.7     1\n9      Burkina Faso     0.30     -0.130  1.1     1\n10            India     0.35     -0.160  8.0     3\n\n\nBây giờ chúng ta có thể thêm màu sắc và kích thước vào geom_point().\n\nggplot(df_plot, aes(x = coverage, y = inequality)) +\n  geom_point(aes(size = size, color = color)) +\n  geom_text(aes(label = country), hjust = -0.2, vjust = 0.2) +\n  xlim(c(-0.35, 0.55)) +\n  ylim(c(-0.17, 0.1))\n\n\n\n\nCác quốc gia chính đã được vẽ xong, chúng ta cần có các điểm khác trên biểu đồ mà không có tên quốc gia. Có thể tạo ra các điểm ngẫu nhiên như vậy bằng R.\n\nset.seed(123)\nnp <- 50\nrd <- data.frame(country = rep(\"\", np),\n                 coverage = rnorm(n = np, mean = 0.1, sd = 0.12),\n                 inequality = rnorm(n = np, mean = -0.05, sd = 0.04),\n                 size = rnorm(n = np, mean = 1, sd = 0.4),\n                 color = sample(1:6, np, replace = T))\nhead(rd)\n\n  country   coverage   inequality      size color\n1         0.03274292 -0.039867259 0.7158374     2\n2         0.07237870 -0.051141870 1.1027535     2\n3         0.28704500 -0.051714818 0.9013232     1\n4         0.10846101  0.004744091 0.8609830     2\n5         0.11551453 -0.059030839 0.6193526     1\n6         0.30580780  0.010658824 0.9819889     5\n\n\n\nset.seed(123): dùng để cố định cách tạo ra các điểm ngẫu nhiên.\nnp <- 50: tạo ra 50 điểm ngẫu nhiên.\ncountry = rep(\"\", np): các điểm này không có tên quốc gia.\ncoverage = rnorm(n = np, mean = 0.1, sd = 0.12): sự thay đổi độ phủ vaccine (giá trị trên trục x) của các điểm này là số thực được tạo ra ngẫu nhiên theo phân phối bình thường với trung bình là 0.1 và độ lệch chuẩn là 0.12.\ninequality = rnorm(n = np, mean = -0.05, sd = 0.04): sự thay đổi bất bình đẳng địa lý (giá trị trên trục y) của các điểm này là số thực được tạo ra ngẫu nhiên theo phân phối bình thường với trung bình là -0.05 và độ lệch chuẩn là 0.04.\nsize = rnorm(n = np, mean = 1, sd = 0.4): kích thước của các điểm này là số thực được tạo ra ngẫu nhiên theo phân phối bình thường với trung bình là 1 và độ lệch chuẩn là 0.4.\ncolor = sample(1:6, np, replace = T): màu sắc là số nguyên ngẫu nhiên từ 1 đến 6.\n\nBây giờ chúng ta ghép data frame rd này với data frame của biểu đồ df_plot. Cột màu sắc được đưa về dạng factor để hiển thị màu. Sau đó dùng code ggplot trên để vẽ.\n\ndf_plot <- rbind(df_plot, rd)\ndf_plot$color <- factor(df_plot$color)\nggplot(df_plot, aes(x = coverage, y = inequality)) +\n  geom_point(aes(size = size, color = color)) +\n  geom_text(aes(label = country), hjust = -0.2, vjust = 0.2) +\n  xlim(c(-0.35, 0.55)) +\n  ylim(c(-0.17, 0.1))\n\n\n\n\n\n\n7.1.2 Kết quả\nBiểu đồ được tạo ra đã tương đối giống biểu đồ gốc. Chúng ta có thể thêm các đường thẳng x = 0, y = 0, chọn bảng màu, chỉnh lại kích thước các điểm, chọn lại theme cho biểu đồ để nhìn giống biểu đồ gốc hơn.\n\nggplot(df_plot, aes(x = coverage, y = inequality)) +\n  geom_point(aes(size = size, color = color), alpha = 0.8) +\n  geom_text(aes(label = country), hjust = -0.2, vjust = 0.2) +\n  xlim(c(-0.35, 0.55)) +\n  ylim(c(-0.17, 0.1)) +\n  geom_vline(xintercept = 0) +\n  geom_hline(yintercept = 0) +\n  scale_color_npg() +\n  scale_size_continuous(range = c(0, 10)) +\n  theme_classic() +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\nBài tập\n\n\n\nThay đổi tiêu đề của các trục tọa độ và chú thích kích thước điểm, màu cho giống với biểu đồ mẫu. Đặt phần chú thích ở trên biểu đồ giống như biểu đồ mẫu.\n\n\n\n\n\n\n1. Mapping routine measles vaccination in low- and middle-income countries. Nature 589, 415–419 (2020)."
  },
  {
    "objectID": "report.html#giới-thiệu-file-rmd",
    "href": "report.html#giới-thiệu-file-rmd",
    "title": "8  Làm báo cáo bằng R Markdown",
    "section": "8.1 Giới thiệu file Rmd",
    "text": "8.1 Giới thiệu file Rmd\n\n8.1.1 File .R vs .Rmd (R markdown)\n\nFile .R: chỉ chứa các lệnh R\nFile .Rmd: thường được dùng cho báo cáo vì có thể kết hợp các lệnh R, văn bản thường, đồ thị trong 1 file \n\n\n\n8.1.2 Cấu trúc file Rmd\nGồm 3 phần chính:\n\nphần YAML header: nằm ở trên cùng trong và ngăn cách với phần còn lại bằng cặp dấu ---. Phần này để mô tả tiêu đề tài liệu, tác giả, ngày tháng, định dạng mong muốn\nPhần văn bản (được viết bằng ngôn ngữ markdown)\nPhần lệnh R (được gọi là chunk). Phần kết quả của câu lệnh R có thể hiển thị dưới dạng string, bảng dữ liệu hoặc đồ thị.\n\n\n\n\n8.1.3 Markdown\nNgười dùng có thể điều chỉnh format (VD: heading, in đậm, in nghiêng) của văn bản trong Markdown bằng cách sử dụng các cú pháp nhất định.\nMột số cú pháp thông dụng:\n\n# Tiêu đề (Heading) - số dấu # tượng trưng cho cấp độ tiêu đề.\nVD:\n\n\n\n\n\n\n\nMarkdown\nOutput\n\n\n\n\n# This is Heading 1\nThis is Heading 1\n\n\n## This is Heading 2\nThis is Heading 2\n\n\n### This is Heading 3\nThis is Heading 3\n\n\n\n* Đặt trước và sau cụm từ. Tuỳ vào số dấu *, văn bản sẽ được in đậm, in nghiêng hoặc cả 2\n\n\n\nMarkdown\nOutput\n\n\n\n\n*Italic*\nItalic\n\n\n**Bold**\nBold\n\n\n***Bold and Italic***\nBold and Italic\n\n\n\n\nTổng hợp các cú pháp markdown\n\n\n\n\n\n\nRmd outline\n\n\n\nTa có thể xem cấu trúc của 1 file Rmd theo 2 cách\n\nBấm Outline để hiện danh sách Header (theo format markdown).\nXem mục lục các Header và Chunk ở thanh ngang gần console.\n\n\n\n\n\n\n\nCách 1\nCách 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n8.1.4 Chunk\nTrong Rmd, chunk có format là \n```{r tên chunk}\ncác dòng lệnh R\n```\nĐể tạo 1 chunk mới, người dùng đặt con trỏ ở vị trí muốn tạo chunk mới → bấm nút tạo chunk (1) → chọn R (2)\n\nĐể chạy chunk, người dùng có thể chọn chạy từng dòng hoặc chạy cả chunk\n\nChạy từng dòng: để con trỏ tại hàng cần chạy → Run → Run Selected Line(s) (Shortcut: Ctrl+Enter)\nChạy cả chunk: \n\nĐể con trỏ tại chunk cần chạy → Run → Run Current Chunk\nHoặc trực tiếp bấm nút Run ở chunk"
  },
  {
    "objectID": "report.html#xuất-file-.rmd-sang-định-dạng-khác",
    "href": "report.html#xuất-file-.rmd-sang-định-dạng-khác",
    "title": "8  Làm báo cáo bằng R Markdown",
    "section": "8.2 Xuất file .Rmd sang định dạng khác",
    "text": "8.2 Xuất file .Rmd sang định dạng khác\nBấm mũi tên bên cạnh chữ Knit → chọn định dạng file xuất (HTML/Word/PDF)"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "1. Ihaka, R. The R\nProject: A Brief History and Thoughts About the Future.\n(1998).\n\n\n2. Ihaka, R. & Gentleman, R. R: A Language for\nData Analysis and Graphics. Journal of Computational and\nGraphical Statistics 5, 299–314 (1996).\n\n\n3. Wickham, H. Tidy Data. Journal\nof Statistical Software 59, (2014).\n\n\n4. Lenovo, Inc. Programming\nLanguage: What is a programming language? (2024).\n\n\n5. Mapping routine\nmeasles vaccination in low- and middle-income countries.\nNature 589, 415–419 (2020)."
  }
]